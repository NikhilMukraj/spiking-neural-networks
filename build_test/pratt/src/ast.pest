integer = @{ ASCII_DIGIT+ }
decimal = @{ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT* }
number = @{ decimal | integer }
name_characters = @{ 'a'..'z' | 'A'..'z' | "_" }

name = @{ name_characters ~ (name_characters | integer)* }

args = {
    (expr | function | name | number)? ~ (" "* ~ "," ~ " "* ~ (expr | function | name | number))* ~ ","?
}
function = { name ~ ("(" ~ args ~ ")") }

unary_minus = { "-" }
primary = _{ function | number | name | "(" ~ expr ~ ")" }

atom = _{ not_operator? ~ unary_minus? ~ primary }

// bin_op = _{ add | subtract | multiply | divide | power }
// 	add = { "+" }
// 	subtract = { "-" }
// 	multiply = { "*" }
// 	divide = { "/" }
// 	power = { "^" }

not_operator = { "!" }

bin_op = _{ 
	greater_than_or_equal | less_than_or_equal | equal | not_equal | 
	greater_than | less_than | and_operator | or_operator |
	add | subtract | multiply | divide | power 
}
	equal = { "==" }
	not_equal = { "!=" }
	greater_than = { ">" }
	greater_than_or_equal = { ">=" }
	less_than = { "<" }
	less_than_or_equal = { "<=" }
	and_operator = { "&&" }
	or_operator = { "||" }
	add = { "+" }
	subtract = { "-" }
	multiply = { "*" }
	divide = { "/" }
	power = { "^" }

expr = { atom ~ (bin_op ~ atom)* }
// bool_expr = { atom ~ (bool_bin_op ~ atom)* }

diff_eq_declaration = { "d" ~ name ~ "/dt" }
eq_declaration = { name }

func_declaration_args = { "(" ~ name ~ (" "* ~ "," ~ " "* ~ name)* ~ ","? ~ ")" }
func_declaration = { name ~ func_declaration_args }

equation = _{ SOI ~ ( func_declaration | diff_eq_declaration | eq_declaration ) ~ " "* ~ "=" ~ " "* ~ expr ~ EOI }

WHITESPACE = _{ " " }

// neuron block
// functions block (has any functions that )
// ion channel block
// neurotransmitter kinetics block
// receptor kinetics block

// neuron should include type of neuron (name of neuron)
// test code generation, and reading from file
// neuron should include list of necessary variables
// variables either all have defaults or none have defaults
// on_spike block, (on_spike: v_reset = 0)
// spike_detection block, (spike_detection: continous), (spike_detection: v >= v_th)
// bool expr grammar, maybe seperate pratt parser for booleans or
// pratt parser has two functions, one is unedited and for evaluating numeric expressions
// the other is for booleans with numerics, bool operators have highest precedence
// if normal expr pratt parser gets a boolean operator, a specific error is thrown saying that boolean was not expected

// seperate pratt parsers, one for expr and one for bool expr
// bool_expr = { atom ~ (bin_bool_op ~ atom)* }

// neuron block should have option to either be extendable (ligand gates and neurotransmitter default implementation)
// or custom (custom ligand gates, ligand gates block)

// when checking for type and what ligand gates to use, 
// just keep matching on each pair in neuron block and assign them to an associated ast enum 
// (ligand gates declaration, type declaration, equations, on spike, etc), 
// then loop through each of the ast enums and add them to the appropriate field on the 
// neuron block ast enum, if a certain enum cannot be found the declaration is missing and an 
// error is thrown

// type: NeuronName
// on_spike: assignments
// spike_detection: bool_expr
// ligand_gates: default

// variables_block = { "vars:" ~ " "* ~ name ~ (" "* ~ "," ~ " "* ~ name)* ~ ","? }
// variables_with_default = { 
// 	"vars:" ~ " "* ~ name ~ " "* ~ "=" ~ " "* ~ unary_minus? ~ number ~ 
//     (" "* ~ "," ~ " "* ~ name ~ " "* ~ "=" ~ " "* ~ unary_minus? ~number)* ~ 
//     ","? 
// }

// eq_assignments = { (eq_declaration ~ " "* ~ "=" ~ " "* ~ expr) ~ (NEWLINE* ~ (eq_declaration ~ " "* ~ "=" ~ " "* ~ expr))* ~ NEWLINE? }
// assignments = {
// 	(( func_declaration | diff_eq_declaration | eq_declaration ) ~ " "* ~ "=" ~ " "* ~ expr) ~ 
// 	(NEWLINE* ~ (( func_declaration | diff_eq_declaration | eq_declaration ) ~ " "* ~ "=" ~ " "* ~ expr))* ~ 
// 	NEWLINE?
// }

// type_def = { "type:" ~ " "* ~ name ~ NEWLINE+ }
// vars_def  = { (variables_with_default ~ NEWLINE+) | (variables_block ~ NEWLINE+) }
// on_spike_def = { "on_spike:" ~ " "* ~ NEWLINE+ ~ eq_assignments }
// on_iteration_def = { "on_iteration:" ~ " "* ~ NEWLINE+ ~ assignments }
// spike_detection_def = { "spike_detection:" ~ " "* ~ expr ~ NEWLINE+ }
// ligand_gates_def = { "ligand_gates:" ~ " "* ~ name ~ NEWLINE+ }

// neuron_definition = {
//     "[neuron]" ~ NEWLINE ~ 
// 	(on_iteration_def | type_def | vars_def | on_spike_def | spike_detection_def | ligand_gates_def){3,} ~ 
// 	"[end]"
// }

// Parser::parse(Rule::neuron_definition, input)
// fn check_neuron_definition(pairs: Pairs<Rule>) -> Result<(), String> {
//     let mut keys_found = HashSet::new();
//     let required_keys = ["type", "on_spike", "spike_detection", "ligand_gates"];

//     for pair in pairs {
//         match pair.as_rule() {
//             Rule::type_def => {
//                 if !keys_found.insert("type") {
//                     return Err("Duplicate 'type' definition found.".into());
//                 }
//             },
//             Rule::on_spike_def => {
//                 if !keys_found.insert("on_spike") {
//                     return Err("Duplicate 'on_spike' definition found.".into());
//                 }
//             },
//             Rule::spike_detection_def => {
//                 if !keys_found.insert("spike_detection") {
//                     return Err("Duplicate 'spike_detection' definition found.".into());
//                 }
//             },
//             Rule::ligand_gates_def => {
//                 if !keys_found.insert("ligand_gates") {
//                     return Err("Duplicate 'ligand_gates' definition found.".into());
//                 }
//             },
//             _ => {}
//         }
//     }

//     for key in &required_keys {
//         if !keys_found.contains(key) {
//             return Err(format!("Missing '{}' definition.", key));
//         }
//     }

//     Ok(())
// }

// [ligand_gates]
// type: name
// neurotransmitter_type: g * r * (voltage - e)
// â€¦
// for custom ligand gates, a ligand gate struct is generated for each associated neurotransmitter type, 
// which are then put in a ligand gated channels struct

// allow functions to have if statements
// if () -> () else -> ()
// if () -> () elif () -> () else -> ()
// allow nextlines with if statements

