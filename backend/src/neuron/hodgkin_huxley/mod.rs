//! An implementation of a Hodgkin Huxley neuron with neurotransmission, receptor kinetics,
//! and the option to add an arbitrary additional ion channel gate to the model

use std::{
    collections::HashMap,
    ops::Sub,
};
use super::{ 
    iterate_and_spike::{
        IterateAndSpike, GaussianFactor, GaussianParameters, CurrentVoltage,
        GapConductance, STDPParameters, STDP, Potentiation, PotentiationType, 
        LastFiringTime, LigandGatedChannels, NeurotransmitterConcentrations, 
        NeurotransmitterKinetics, Neurotransmitters, ReceptorKinetics,
    },
    impl_gaussian_factor_with_kinetics, 
    impl_current_voltage_with_kinetics, 
    impl_gap_conductance_with_kinetics, 
    impl_last_firing_time_with_kinetics, 
    impl_necessary_iterate_and_spike_traits, 
    impl_potentiation_with_kinetics, 
    impl_stdp_with_kinetics, 
};


// CHECK THIS PAPER TO CREATE MORE ION CHANNELS WHEN REFACTORING
// https://sci-hub.se/https://pubmed.ncbi.nlm.nih.gov/25282547/

// https://webpages.uidaho.edu/rwells/techdocs/Biological%20Signal%20Processing/Chapter%2004%20The%20Biological%20Neuron.pdf

// https://www.nature.com/articles/356441a0.pdf : calcium currents paper
// https://github.com/ModelDBRepository/151460/blob/master/CaT.mod // low threshold calcium current
// https://modeldb.science/279?tab=1 // low threshold calcium current (thalamic)
// https://github.com/gpapamak/snl/blob/master/IL_gutnick.mod // high threshold calcium current (l type)
// https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9373714/ // assume [Ca2+]in,inf is initial [Ca2+] value

/// Handles dynamics of any additional ion channels
pub trait AdditionalGate: AdditionalGateClone + Sync + Send {
    /// Initializes parameters based on a starting voltage (mV)
    fn initialize(&mut self, voltage: f64);
    /// Updates current based on the current voltage (mV) and a timestep (ms)
    fn update_current(&mut self, voltage: f64, dt: f64);
    /// Returns the current
    fn get_current(&self) -> f64;
    /// Returns the name of the gate
    fn name(&self) -> &str;
}

/// Handles cloning of additional gates
pub trait AdditionalGateClone {
    fn clone_box(&self) -> Box<dyn AdditionalGate>;
}

impl<T: ?Sized> AdditionalGateClone for T
where
    T: 'static + AdditionalGate + Clone,
{
    fn clone_box(&self) -> Box<dyn AdditionalGate> {
        Box::new(self.clone())
    }
}

impl Clone for Box<dyn AdditionalGate> {
    fn clone(&self) -> Box<dyn AdditionalGate> {
        self.clone_box()
    }
}

/// An implementation of a calcium channel
#[derive(Debug, Clone, Copy)]
pub struct HighVoltageActivatedCalciumChannel {
    m: f64,
    m_a: f64,
    m_b: f64,
    h: f64,
    h_a: f64,
    h_b: f64,
    /// Maximal conductance of the channel (nS)
    pub g_ca: f64,
    /// Reversal potential (mV)
    pub ca_rev: f64,
    /// Current generated by channel
    pub current: f64,
}

impl Default for HighVoltageActivatedCalciumChannel {
    fn default() -> Self {
        HighVoltageActivatedCalciumChannel {
            m: 0.,
            m_a: 0.,
            m_b: 0.,
            h: 0.,
            h_a: 0.,
            h_b: 0.,
            g_ca: 1e-4,
            ca_rev: 80.,
            current: 0.,
        }
    }
}

// https://github.com/ModelDBRepository/121060/blob/master/chan_CaL12.mod
// https://github.com/gpapamak/snl/blob/master/IL_gutnick.mod
impl HighVoltageActivatedCalciumChannel {
    fn update_m(&mut self, voltage: f64) {
        self.m_a = 0.055 * (-27. - voltage) / (((-27. - voltage) / 3.8).exp() - 1.);
        self.m_b = 0.94 * ((-75. - voltage) / 17.).exp();
    }

    fn update_h(&mut self, voltage: f64) {
        self.h_a = 0.000457 * ((-13. - voltage) / 50.).exp();
        self.h_b = 0.0065 / (((-15. - voltage) / 28.).exp() + 1.);
    }

    fn update_m_and_h_states(&mut self, voltage: f64, dt: f64) {
        self.update_m(voltage);
        self.update_h(voltage);

        self.m += (self.m_a * (1. - self.m) - (self.m_b * self.m)) * dt;
        self.h += (self.h_a * (1. - self.h) - (self.h_b * self.h)) * dt;
    }
}

impl AdditionalGate for HighVoltageActivatedCalciumChannel {
    fn initialize(&mut self, voltage: f64) {
        self.update_m(voltage);
        self.update_h(voltage);

        self.m = self.m_a / (self.m_a + self.m_b);
        self.h = self.h_a / (self.h_a + self.h_b);
    } 

    fn update_current(&mut self, voltage: f64, dt: f64) {
        self.update_m_and_h_states(voltage, dt);
        self.current = self.g_ca * self.m.powf(2.) * self.h * (voltage - self.ca_rev);
    }

    fn get_current(&self) -> f64 {
        self.current
    }

    fn name(&self) -> &str {
        "HVA Ca"
    }
}

// multicomparment stuff, refer to dopamine modeling paper as well
// https://github.com/antgon/msn-model/blob/main/msn/cell.py 
// https://github.com/jrieke/NeuroSim
// MULTICOMPARTMENT EXPLAINED
// https://neuronaldynamics.epfl.ch/online/Ch3.S2.html
// pub struct Soma {

// }

// pub struct Dendrite {

// }

/// A basic gate for necessary ion channels in `HodgkinHuxleyNeuron`
#[derive(Clone, Copy)]
pub struct Gate {
    /// Gating variable
    pub alpha: f64,
    /// Gating variable
    pub beta: f64,
    /// Current state of the gate
    pub state: f64,
}

impl Gate {
    pub fn init_state(&mut self) {
        self.state = self.alpha / (self.alpha + self.beta);
    }

    pub fn update(&mut self, dt: f64) {
        let alpha_state: f64 = self.alpha * (1. - self.state);
        let beta_state: f64 = self.beta * self.state;
        self.state += dt * (alpha_state - beta_state);
    }
}

pub struct HodgkinHuxleyNeuron<T: NeurotransmitterKinetics, R: ReceptorKinetics> {
    /// Membrane potential (mV)
    pub current_voltage: f64,
    /// Controls conductance of input gap junctions
    pub gap_conductance: f64,
    /// Timestep (ms)
    pub dt: f64,
    /// Membrane capacitance (nF)
    pub c_m: f64,
    /// Reversal potential of sodium ion channel (mV)
    pub e_na: f64,
    /// Reversal potential of potassium ion channel (mV)
    pub e_k: f64,
    /// Reversal potential of leak ion channel (mV)
    pub e_k_leak: f64,
    /// Maximal conductance of sodium ion channel (nS)
    pub g_na: f64,
    /// Maximal conductance of potassium ion channel (nS)
    pub g_k: f64,
    /// Maximal conductance of leak channel (nS)
    pub g_k_leak: f64,
    /// Gating variable
    pub m: Gate,
    /// Gating variable
    pub n: Gate,
    /// Gating variable
    pub h: Gate,
    /// Voltage threshold for spike calculation (mV)
    pub v_th: f64,
    /// Last timestep the neuron has spiked
    pub last_firing_time: Option<usize>,
    /// Whether the voltage was increasing in the last step
    pub was_increasing: bool,
    /// Whether the neuron is currently spiking
    pub is_spiking: bool,
    /// Potentiation type of neuron
    pub potentiation_type: PotentiationType,
    /// Additional ion gates
    pub additional_gates: Vec<Box<dyn AdditionalGate>>,
    /// STDP parameters
    pub stdp_params: STDPParameters,
    /// Parameters used in generating noise
    pub gaussian_params: GaussianParameters,
    /// Postsynaptic neurotransmitters in cleft
    pub synaptic_neurotransmitters: Neurotransmitters<T>,
    /// Ionotropic receptor ligand gated channels
    pub ligand_gates: LigandGatedChannels<R>,
}

impl<T: NeurotransmitterKinetics, R: ReceptorKinetics> Clone for HodgkinHuxleyNeuron<T, R> {
    fn clone(&self) -> Self {
        Self {
            current_voltage: self.current_voltage,
            gap_conductance: self.gap_conductance,
            potentiation_type: self.potentiation_type.clone(),
            dt: self.dt,
            c_m: self.c_m,
            e_na: self.e_na,
            e_k: self.e_k,
            e_k_leak: self.e_k_leak,
            g_na: self.g_na,
            g_k: self.g_k,
            g_k_leak: self.g_k_leak,
            m: self.m.clone(),
            n: self.n.clone(),
            h: self.h.clone(),
            v_th: self.v_th,
            last_firing_time: self.last_firing_time.clone(),
            was_increasing: self.was_increasing,
            is_spiking: self.is_spiking,
            additional_gates: self.additional_gates.iter()
                .map(|gate| gate.clone_box())
                .collect(),
            synaptic_neurotransmitters: self.synaptic_neurotransmitters.clone(),
            ligand_gates: self.ligand_gates.clone(),
            gaussian_params: self.gaussian_params.clone(),
            stdp_params: self.stdp_params.clone(),
        }
    }
}

impl_necessary_iterate_and_spike_traits!(HodgkinHuxleyNeuron);

impl<T: NeurotransmitterKinetics, R: ReceptorKinetics> Default for HodgkinHuxleyNeuron<T, R> {
    fn default() -> Self {
        let default_gate = Gate {
            alpha: 0.,
            beta: 0.,
            state: 0.,
        };

        HodgkinHuxleyNeuron { 
            current_voltage: 0.,
            gap_conductance: 7.,
            potentiation_type: PotentiationType::Excitatory,
            dt: 0.1,
            c_m: 1., 
            e_na: 115., 
            e_k: -12., 
            e_k_leak: 10.6, 
            g_na: 120., 
            g_k: 36., 
            g_k_leak: 0.3, 
            m: default_gate.clone(), 
            n: default_gate.clone(), 
            h: default_gate,  
            v_th: 60.,
            last_firing_time: None,
            is_spiking: false,
            was_increasing: false,
            synaptic_neurotransmitters: Neurotransmitters::default(), 
            ligand_gates: LigandGatedChannels::default(),
            additional_gates: vec![],
            gaussian_params: GaussianParameters::default(),
            stdp_params: STDPParameters::default(),
        }
    }
}

fn diff<T: Sub<Output = T> + Copy>(x: &Vec<T>) -> Vec<T> {
    (1..x.len()).map(|i| x[i] - x[i-1])
        .collect()
}

/// Returns indices of where voltages have peaked given a certain tolerance
pub fn find_peaks(voltages: &Vec<f64>, tolerance: f64) -> Vec<usize> {
    let first_diff: Vec<f64> = diff(&voltages);
    let second_diff: Vec<f64> = diff(&first_diff);

    let local_optima = first_diff.iter()
        .enumerate()
        .filter(|(_, i)| i.abs() <= tolerance)
        .map(|(n, i)| (n, *i))
        .collect::<Vec<(usize, f64)>>();

    let local_maxima = local_optima.iter()
        .map(|(n, i)| (*n, *i))
        .filter(|(n, _)| *n < second_diff.len() - 1 && second_diff[n+1] < 0.)
        .collect::<Vec<(usize, f64)>>();

    let local_maxima: Vec<usize> = local_maxima.iter()
        .map(|(n, _)| (n + 2))
        .collect();

    let mut peak_spans: Vec<Vec<usize>> = Vec::new();

    let mut index: usize = 0;
    for (n, i) in local_maxima.iter().enumerate() {
        if n > 0 && local_maxima[n] - local_maxima[n-1] != 1 {
            index += 1;
        }

        if peak_spans.len() - 1 != index {
            peak_spans.push(Vec::new());
        }

        peak_spans[index].push(*i);
    }

    peak_spans.iter()
        .map(|i| i[i.len() / 2])
        .collect::<Vec<usize>>()
}

// https://github.com/swharden/pyHH/blob/master/src/pyhh/models.py
impl<T: NeurotransmitterKinetics, R: ReceptorKinetics> HodgkinHuxleyNeuron<T, R> {
    /// Updates gate time constants
    pub fn update_gate_time_constants(&mut self) {
        self.n.alpha = 0.01 * (10. - self.current_voltage) / (((10. - self.current_voltage) / 10.).exp() - 1.);
        self.n.beta = 0.125 * (-self.current_voltage / 80.).exp();
        self.m.alpha = 0.1 * ((25. - self.current_voltage) / (((25. - self.current_voltage) / 10.).exp() - 1.));
        self.m.beta = 4. * (-self.current_voltage / 18.).exp();
        self.h.alpha = 0.07 * (-self.current_voltage / 20.).exp();
        self.h.beta = 1. / (((30. - self.current_voltage) / 10.).exp() + 1.);
    }

    /// Initializes parameters based on a starting voltage (mV)
    pub fn initialize_parameters(&mut self, starting_voltage: f64) {
        self.current_voltage = starting_voltage;
        self.update_gate_time_constants();
        self.m.init_state();
        self.n.init_state();
        self.h.init_state();

        self.additional_gates.iter_mut()
            .for_each(|i| i.initialize(starting_voltage));
    }

    /// Updates cell voltage given an input current
    pub fn update_cell_voltage(&mut self, input_current: f64) {
        let i_na = self.m.state.powf(3.) * self.g_na * self.h.state * (self.current_voltage - self.e_na);
        let i_k = self.n.state.powf(4.) * self.g_k * (self.current_voltage - self.e_k);
        let i_k_leak = self.g_k_leak * (self.current_voltage - self.e_k_leak);

        let i_ligand_gates = self.ligand_gates.get_receptor_currents(self.dt, self.c_m);

        let i_additional_gates = self.additional_gates
            .iter()
            .map(|i| 
                i.get_current()
            ) 
            .sum::<f64>();

        let i_sum = input_current - (i_na + i_k + i_k_leak) + i_ligand_gates + i_additional_gates;
        self.current_voltage += self.dt * i_sum / self.c_m;
    }

    /// Updates neurotransmitter concentrations based on membrane potential
    pub fn update_neurotransmitters(&mut self) {
        self.synaptic_neurotransmitters.apply_t_changes(self.current_voltage);
    }

    /// Updates receptor gating based on neurotransmitter input
    pub fn update_receptors(
        &mut self, 
        t_total: Option<&NeurotransmitterConcentrations>
    ) {
        self.ligand_gates.update_receptor_kinetics(t_total);
        self.ligand_gates.set_receptor_currents(self.current_voltage);
    }

    /// Updates gating states
    pub fn update_gate_states(&mut self) {
        self.m.update(self.dt);
        self.n.update(self.dt);
        self.h.update(self.dt);
    }

    /// Updates additional ion channels
    pub fn update_additional_gates(&mut self) {
        self.additional_gates.iter_mut()
            .for_each(|i| {
                i.update_current(self.current_voltage, self.dt);
        });
    }

    fn iterate(&mut self, input: f64) {
        self.update_gate_time_constants();
        self.update_cell_voltage(input);
        self.update_gate_states();
        self.update_additional_gates();
        self.update_neurotransmitters();
    }

    fn iterate_with_neurotransmitter(
        &mut self, 
        input: f64, 
        t_total: Option<&NeurotransmitterConcentrations>
    ) {
        self.update_receptors(t_total);
        self.iterate(input);
    }
}

impl<T: NeurotransmitterKinetics, R: ReceptorKinetics> IterateAndSpike for HodgkinHuxleyNeuron<T, R> {
    type T = T;
    type R = R;

    fn iterate_and_spike(&mut self, input_current: f64) -> bool {
        let last_voltage = self.current_voltage;
        self.iterate(input_current);

        let increasing_right_now = last_voltage < self.current_voltage;
        let threshold_crossed = self.current_voltage > self.v_th;
        let is_spiking = threshold_crossed  && self.was_increasing && !increasing_right_now;
        self.is_spiking = is_spiking;
        self.was_increasing = increasing_right_now;

        is_spiking
    }

    fn get_ligand_gates(&self) -> &LigandGatedChannels<R> {
        &self.ligand_gates
    }

    fn get_neurotransmitters(&self) -> &Neurotransmitters<T> {
        &self.synaptic_neurotransmitters
    }

    fn get_neurotransmitter_concentrations(&self) -> NeurotransmitterConcentrations {
        self.synaptic_neurotransmitters.get_concentrations()
    }

    fn iterate_with_neurotransmitter_and_spike(
        &mut self, 
        input_current: f64, 
        t_total: Option<&NeurotransmitterConcentrations>,
    ) -> bool {
        let last_voltage = self.current_voltage;
        self.iterate_with_neurotransmitter(input_current, t_total);

        let increasing_right_now = last_voltage < self.current_voltage;
        let threshold_crossed = self.current_voltage > self.v_th;
        let is_spiking = threshold_crossed  && self.was_increasing && !increasing_right_now;

        self.is_spiking = is_spiking;
        self.was_increasing = increasing_right_now;

        is_spiking
    }
}

/// Takes in a static current as an input and iterates the given
/// neuron for a given duration, set `gaussian` to true to add 
/// normally distributed noise to the input as it iterates,
/// returns various state variables over time including voltages
/// and gating states
pub fn run_static_input_hodgkin_huxley<T: NeurotransmitterKinetics, R: ReceptorKinetics>(
    hodgkin_huxley_neuron: &mut HodgkinHuxleyNeuron<T, R>,
    input: f64,
    gaussian: bool,
    iterations: usize,
) -> HashMap<String, Vec<f64>> {
    let mut state_output = HashMap::new();
    state_output.insert("current_voltage".to_string(), vec![]);
    state_output.insert("m".to_string(), vec![]);
    state_output.insert("n".to_string(), vec![]);
    state_output.insert("h".to_string(), vec![]);

    for _ in 0..iterations {
        let current_input = if gaussian {
            input * hodgkin_huxley_neuron.get_gaussian_factor()
        } else {
            input
        };

        let _is_spiking = hodgkin_huxley_neuron.iterate_and_spike(current_input);

        state_output.get_mut("current_voltage").map(|val| val.push(hodgkin_huxley_neuron.current_voltage));
        state_output.get_mut("m").map(|val| val.push(hodgkin_huxley_neuron.m.state));
        state_output.get_mut("n").map(|val| val.push(hodgkin_huxley_neuron.n.state));
        state_output.get_mut("h").map(|val| val.push(hodgkin_huxley_neuron.h.state));
    }

    state_output
}
