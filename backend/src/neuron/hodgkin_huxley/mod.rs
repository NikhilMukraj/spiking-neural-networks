//! An implementation of a Hodgkin Huxley neuron with neurotransmission, receptor kinetics,
//! and the option to add an arbitrary additional ion channel gate to the model

use std::{
    collections::HashMap,
    ops::Sub,
};
use iterate_and_spike_traits::IterateAndSpikeBase;
use super::iterate_and_spike::{
    IterateAndSpike, GaussianFactor, GaussianParameters, CurrentVoltage, IsSpiking,
    GapConductance, STDPParameters, STDP, Potentiation, PotentiationType, 
    LastFiringTime, LigandGatedChannels, NeurotransmitterConcentrations, 
    NeurotransmitterKinetics, Neurotransmitters, ReceptorKinetics,
    DestexheNeurotransmitter, DestexheReceptor,
};


// CHECK THIS PAPER TO CREATE MORE ION CHANNELS WHEN REFACTORING
// https://sci-hub.se/https://pubmed.ncbi.nlm.nih.gov/25282547/

// https://webpages.uidaho.edu/rwells/techdocs/Biological%20Signal%20Processing/Chapter%2004%20The%20Biological%20Neuron.pdf

// https://www.nature.com/articles/356441a0.pdf : calcium currents paper
// https://github.com/ModelDBRepository/151460/blob/master/CaT.mod // low threshold calcium current
// https://modeldb.science/279?tab=1 // low threshold calcium current (thalamic)
// https://github.com/gpapamak/snl/blob/master/IL_gutnick.mod // high threshold calcium current (l type)
// https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9373714/ // assume [Ca2+]in,inf is initial [Ca2+] value

/// Handles dynamics of an ion channel
pub trait IonChannel: IonChannelBoxClone + Sync + Send {
    /// Initializes parameters based on a starting voltage (mV)
    fn initialize(&mut self, voltage: f32);
    /// Updates current based on the current voltage (mV) and a timestep (ms)
    fn update_current(&mut self, voltage: f32, dt: f32);
    /// Returns the current
    fn get_current(&self) -> f32;
    /// Returns the name of the gate
    fn gate_type(&self) -> &str;
}

/// Handles cloning of boxed dynamic ion channels
pub trait IonChannelBoxClone {
    fn clone_box(&self) -> Box<dyn IonChannel>;
}

impl<T: ?Sized> IonChannelBoxClone for T
where
    T: 'static + IonChannel + Clone,
{
    fn clone_box(&self) -> Box<dyn IonChannel> {
        Box::new(self.clone())
    }
}

impl Clone for Box<dyn IonChannel> {
    fn clone(&self) -> Box<dyn IonChannel> {
        self.clone_box()
    }
}

// /// An implementation of a calcium channel
// #[derive(Debug, Clone, Copy)]
// pub struct CalciumIonChannel {
//     /// Maximal conductance of the channel (nS)
//     pub g_ca: f32,
//     /// Reversal potential (mV)
//     pub e_ca: f32,
//     /// Gating variable
//     pub s: GatingVariable,
//     /// Current generated by channel
//     pub current: f32,
// }

// impl Default for CalciumIonChannel {
//     fn default() -> Self {
//         CalciumIonChannel {
//             g_ca: 2.5,
//             e_ca: 80.,
//             s: GatingVariable::default(),
//             current: 0.,
//         }
//     }
// }

// // https://github.com/ModelDBRepository/121060/blob/master/chan_CaL12.mod
// // https://github.com/gpapamak/snl/blob/master/IL_gutnick.mod
// impl CalciumIonChannel {
//     fn update_gate_states(&mut self, voltage: f32) {
//         self.s.alpha = 1.6 / (1. + (-0.072 * (voltage - 5.)).exp());
//         self.s.beta = (0.02 * (voltage + 8.9)) / (((voltage + 8.9).exp() / 5.) - 1.);
//     }
// }

// impl IonChannel for CalciumIonChannel {
//     fn initialize(&mut self, voltage: f32) {
//         self.update_gate_states(voltage);

//         self.s.init_state()
//     } 

//     fn update_current(&mut self, voltage: f32, dt: f32) {
//         self.update_gate_states(voltage);

//         self.s.update(dt);

//         self.current = self.s.state.powf(2.) * self.g_ca * (voltage - self.e_ca);
//     }

//     fn get_current(&self) -> f32 {
//         self.current
//     }

//     fn gate_type(&self) -> &str {
//         "Ca"
//     }
// }

#[derive(Debug, Clone, Copy)]
pub struct NaIonChannel {
    pub g_na: f32,
    pub e_na: f32,
    pub m: GatingVariable,
    pub h: GatingVariable,
    pub current: f32,
}

impl Default for NaIonChannel {
    fn default() -> Self {    
        NaIonChannel {
            g_na: 120., 
            e_na: 115., 
            m: GatingVariable::default(),
            h: GatingVariable::default(),
            current: 0.,
        }
    }
}

impl NaIonChannel {
    fn update_gate_states(&mut self, voltage: f32) {
        self.m.alpha = 0.1 * ((25. - voltage) / (((25. - voltage) / 10.).exp() - 1.));
        self.m.beta = 4. * (-voltage / 18.).exp();
        self.h.alpha = 0.07 * (-voltage / 20.).exp();
        self.h.beta = 1. / (((30. - voltage) / 10.).exp() + 1.);
    }
}

impl IonChannel for NaIonChannel {
    fn initialize(&mut self, voltage: f32) {
        self.update_gate_states(voltage);

        self.m.init_state();
        self.h.init_state();
    }

    fn update_current(&mut self, voltage: f32, dt: f32) {
        self.update_gate_states(voltage);

        self.m.update(dt);
        self.h.update(dt);

        self.current = self.m.state.powf(3.) * self.h.state * self.g_na * (voltage - self.e_na);
    }

    fn get_current(&self) -> f32 {
        self.current
    }

    fn gate_type(&self) -> &str {
        "Na"
    }
}

#[derive(Debug, Clone, Copy)]
pub struct KIonChannel {
    g_k: f32,
    e_k: f32,
    n: GatingVariable,
    current: f32,
}

impl Default for KIonChannel {
    fn default() -> Self {
        KIonChannel {
            g_k: 36., 
            e_k: -12., 
            n: GatingVariable::default(),
            current: 0.,
        }
    }
}

impl KIonChannel {
    fn update_gate_states(&mut self, voltage: f32) {
        self.n.alpha = 0.01 * (10. - voltage) / (((10. - voltage) / 10.).exp() - 1.);
        self.n.beta = 0.125 * (-voltage / 80.).exp();
    }
}

impl IonChannel for KIonChannel {
    fn initialize(&mut self, voltage: f32) {
        self.update_gate_states(voltage);

        self.n.init_state();
    }

    fn update_current(&mut self, voltage: f32, dt: f32) {
        self.update_gate_states(voltage);

        self.n.update(dt);

        self.current = self.n.state.powf(4.) * self.g_k * (voltage - self.e_k);
    }

    fn get_current(&self) -> f32 {
        self.current
    }

    fn gate_type(&self) -> &str {
        "K"
    }
}

#[derive(Debug, Clone, Copy)]
pub struct KLeakChannel {
    pub g_k_leak: f32,
    pub e_k_leak: f32,
    pub current: f32,
}

impl Default for KLeakChannel {
    fn default() -> Self {
        KLeakChannel {
            g_k_leak: 0.3, 
            e_k_leak: 10.6, 
            current: 0.,
        }
    }
}

impl IonChannel for KLeakChannel {
    fn initialize(&mut self, _: f32) {}

    fn update_current(&mut self, voltage: f32, _: f32) {
        self.current = self.g_k_leak * (voltage - self.e_k_leak);
    }

    fn get_current(&self) -> f32 {
        self.current
    }

    fn gate_type(&self) -> &str {
        "K Leak"
    }
}

// multicomparment stuff, refer to dopamine modeling paper as well
// https://sci-hub.se/https://pubmed.ncbi.nlm.nih.gov/25282547/
// https://github.com/antgon/msn-model/blob/main/msn/cell.py 
// https://github.com/jrieke/NeuroSim
// MULTICOMPARTMENT EXPLAINED
// https://neuronaldynamics.epfl.ch/online/Ch3.S2.html

// should abtract out na+, k+, and leak ion channel to be used in both
// hodgkin huxley and two compartment model, ion channel basically has the following structure:
// g * n * (v - e)
// g being maximal conductance, n being gating variable, v being voltage, e being reversal potential

// dendrite should include receptors while soma should not
// in two compartmental model neurotransmitters are seperate from soma and dendrite
// in multicompartmental model with an axon neurotransmitters should be with the axon

// pub struct Soma {

// }

// pub struct Dendrite<R> {

// }

// there should be a gap junction between the dendrite and the soma to calculate how current travels
// for now current voltage could just be the sum of the two compartment's voltages
// pub TwoCompartmentNeuron<T, R> {
    // pub soma: Soma,
    // pub dendrite: Dendrite<R>,
    // pub synaptic_neurotransmitters: Neurotransmitters<T>
// }

/// A gating variable for necessary ion channels
#[derive(Debug, Clone, Copy)]
pub struct GatingVariable {
    /// Gating variable
    pub alpha: f32,
    /// Gating variable
    pub beta: f32,
    /// Current state of the gate
    pub state: f32,
}

impl Default for GatingVariable {
    fn default() -> Self {
        GatingVariable {
            alpha: 0.,
            beta: 0.,
            state: 0.,
        }
    }
}

impl GatingVariable {
    /// Initializes the gating variable state
    pub fn init_state(&mut self) {
        self.state = self.alpha / (self.alpha + self.beta);
    }

    // Updates the gating variable based on a given timestep (ms)
    pub fn update(&mut self, dt: f32) {
        let alpha_state: f32 = self.alpha * (1. - self.state);
        let beta_state: f32 = self.beta * self.state;
        self.state += dt * (alpha_state - beta_state);
    }
}

#[derive(IterateAndSpikeBase)]
pub struct HodgkinHuxleyNeuron<T: NeurotransmitterKinetics, R: ReceptorKinetics> {
    /// Membrane potential (mV)
    pub current_voltage: f32,
    /// Controls conductance of input gap junctions
    pub gap_conductance: f32,
    /// Timestep (ms)
    pub dt: f32,
    /// Membrane capacitance (nF)
    pub c_m: f32,
    /// Sodium ion channel
    pub na_channel: NaIonChannel,
    /// Potassium ion channel
    pub k_channel: KIonChannel,
    /// Potassium leak channel
    pub k_leak_channel: KLeakChannel,
    /// Voltage threshold for spike calculation (mV)
    pub v_th: f32,
    /// Last timestep the neuron has spiked
    pub last_firing_time: Option<usize>,
    /// Whether the voltage was increasing in the last step
    pub was_increasing: bool,
    /// Whether the neuron is currently spiking
    pub is_spiking: bool,
    /// Potentiation type of neuron
    pub potentiation_type: PotentiationType,
    /// Additional ion gates
    pub additional_gates: Vec<Box<dyn IonChannel>>,
    /// STDP parameters
    pub stdp_params: STDPParameters,
    /// Parameters used in generating noise
    pub gaussian_params: GaussianParameters,
    /// Postsynaptic neurotransmitters in cleft
    pub synaptic_neurotransmitters: Neurotransmitters<T>,
    /// Ionotropic receptor ligand gated channels
    pub ligand_gates: LigandGatedChannels<R>,
}

impl<T: NeurotransmitterKinetics, R: ReceptorKinetics> Clone for HodgkinHuxleyNeuron<T, R> {
    fn clone(&self) -> Self {
        Self {
            current_voltage: self.current_voltage,
            gap_conductance: self.gap_conductance,
            potentiation_type: self.potentiation_type.clone(),
            dt: self.dt,
            c_m: self.c_m,
            na_channel: self.na_channel.clone(),
            k_channel: self.k_channel.clone(),
            k_leak_channel: self.k_leak_channel.clone(),
            v_th: self.v_th,
            last_firing_time: self.last_firing_time.clone(),
            was_increasing: self.was_increasing,
            is_spiking: self.is_spiking,
            additional_gates: self.additional_gates.iter()
                .map(|gate| gate.clone_box())
                .collect(),
            synaptic_neurotransmitters: self.synaptic_neurotransmitters.clone(),
            ligand_gates: self.ligand_gates.clone(),
            gaussian_params: self.gaussian_params.clone(),
            stdp_params: self.stdp_params.clone(),
        }
    }
}

impl<T: NeurotransmitterKinetics, R: ReceptorKinetics> Default for HodgkinHuxleyNeuron<T, R> {
    fn default() -> Self {
        HodgkinHuxleyNeuron { 
            current_voltage: 0.,
            gap_conductance: 7.,
            potentiation_type: PotentiationType::Excitatory,
            dt: 0.01,
            c_m: 1., 
            na_channel: NaIonChannel::default(),
            k_channel: KIonChannel::default(),
            k_leak_channel: KLeakChannel::default(),
            v_th: 60.,
            last_firing_time: None,
            is_spiking: false,
            was_increasing: false,
            synaptic_neurotransmitters: Neurotransmitters::default(), 
            ligand_gates: LigandGatedChannels::default(),
            additional_gates: vec![],
            gaussian_params: GaussianParameters::default(),
            stdp_params: STDPParameters::default(),
        }
    }
}

impl HodgkinHuxleyNeuron<DestexheNeurotransmitter, DestexheReceptor> {
    /// Returns the default implementation of the neuron
    pub fn default_impl() -> Self {
        HodgkinHuxleyNeuron::default()
    }
}

fn diff<T: Sub<Output = T> + Copy>(x: &Vec<T>) -> Vec<T> {
    (1..x.len()).map(|i| x[i] - x[i-1])
        .collect()
}

/// Returns indices of where voltages have peaked given a certain tolerance
pub fn find_peaks(voltages: &Vec<f32>, tolerance: f32) -> Vec<usize> {
    let first_diff: Vec<f32> = diff(&voltages);
    let second_diff: Vec<f32> = diff(&first_diff);

    let local_optima = first_diff.iter()
        .enumerate()
        .filter(|(_, i)| i.abs() <= tolerance)
        .map(|(n, i)| (n, *i))
        .collect::<Vec<(usize, f32)>>();

    let local_maxima = local_optima.iter()
        .map(|(n, i)| (*n, *i))
        .filter(|(n, _)| *n < second_diff.len() - 1 && second_diff[n+1] < 0.)
        .collect::<Vec<(usize, f32)>>();

    let local_maxima: Vec<usize> = local_maxima.iter()
        .map(|(n, _)| (n + 2))
        .collect();

    let mut peak_spans: Vec<Vec<usize>> = Vec::new();

    let mut index: usize = 0;
    for (n, i) in local_maxima.iter().enumerate() {
        if n > 0 && local_maxima[n] - local_maxima[n-1] != 1 {
            index += 1;
        }

        if peak_spans.len() - 1 != index {
            peak_spans.push(Vec::new());
        }

        peak_spans[index].push(*i);
    }

    peak_spans.iter()
        .map(|i| i[i.len() / 2])
        .collect::<Vec<usize>>()
}

// https://github.com/swharden/pyHH/blob/master/src/pyhh/models.py
impl<T: NeurotransmitterKinetics, R: ReceptorKinetics> HodgkinHuxleyNeuron<T, R> {
    /// Initializes parameters based on a starting voltage (mV)
    pub fn initialize_parameters(&mut self, starting_voltage: f32) {
        self.current_voltage = starting_voltage;
        self.na_channel.initialize(self.current_voltage);
        self.k_channel.initialize(self.current_voltage);
        self.k_leak_channel.initialize(self.current_voltage);

        self.additional_gates.iter_mut()
            .for_each(|i| i.initialize(starting_voltage));
    }

    /// Updates cell voltage given an input current
    pub fn update_cell_voltage(&mut self, input_current: f32) {
        let i_na = self.na_channel.current;
        let i_k = self.k_channel.current;
        let i_k_leak = self.k_leak_channel.current;

        let i_ligand_gates = self.ligand_gates.get_receptor_currents(self.dt, self.c_m);

        let i_additional_gates = self.additional_gates
            .iter()
            .map(|i| 
                i.get_current()
            ) 
            .sum::<f32>();

        let i_sum = input_current - (i_na + i_k + i_k_leak) + i_ligand_gates + i_additional_gates;
        self.current_voltage += self.dt * i_sum / self.c_m;
    }

    /// Updates neurotransmitter concentrations based on membrane potential
    pub fn update_neurotransmitters(&mut self) {
        self.synaptic_neurotransmitters.apply_t_changes(self.current_voltage);
    }

    /// Updates receptor gating based on neurotransmitter input
    pub fn update_receptors(
        &mut self, 
        t_total: Option<&NeurotransmitterConcentrations>
    ) {
        self.ligand_gates.update_receptor_kinetics(t_total);
        self.ligand_gates.set_receptor_currents(self.current_voltage);
    }

    /// Updates additional ion channels
    pub fn update_gates(&mut self) {
        self.na_channel.update_current(self.current_voltage, self.dt);
        self.k_channel.update_current(self.current_voltage, self.dt);
        self.k_leak_channel.update_current(self.current_voltage, self.dt);

        self.additional_gates.iter_mut()
            .for_each(|i| {
                i.update_current(self.current_voltage, self.dt);
        });
    }

    fn iterate(&mut self, input: f32) {
        self.update_gates();
        self.update_cell_voltage(input);
        self.update_neurotransmitters();
    }

    fn iterate_with_neurotransmitter(
        &mut self, 
        input: f32, 
        t_total: Option<&NeurotransmitterConcentrations>
    ) {
        self.update_receptors(t_total);
        self.iterate(input);
    }
}

impl<T: NeurotransmitterKinetics, R: ReceptorKinetics> IterateAndSpike for HodgkinHuxleyNeuron<T, R> {
    type T = T;
    type R = R;

    fn iterate_and_spike(&mut self, input_current: f32) -> bool {
        let last_voltage = self.current_voltage;
        self.iterate(input_current);

        let increasing_right_now = last_voltage < self.current_voltage;
        let threshold_crossed = self.current_voltage > self.v_th;
        let is_spiking = threshold_crossed && self.was_increasing && !increasing_right_now;

        self.is_spiking = is_spiking;
        self.was_increasing = increasing_right_now;

        is_spiking
    }

    fn get_ligand_gates(&self) -> &LigandGatedChannels<R> {
        &self.ligand_gates
    }

    fn get_neurotransmitters(&self) -> &Neurotransmitters<T> {
        &self.synaptic_neurotransmitters
    }

    fn get_neurotransmitter_concentrations(&self) -> NeurotransmitterConcentrations {
        self.synaptic_neurotransmitters.get_concentrations()
    }

    fn iterate_with_neurotransmitter_and_spike(
        &mut self, 
        input_current: f32, 
        t_total: Option<&NeurotransmitterConcentrations>,
    ) -> bool {
        let last_voltage = self.current_voltage;
        self.iterate_with_neurotransmitter(input_current, t_total);

        let increasing_right_now = last_voltage < self.current_voltage;
        let threshold_crossed = self.current_voltage > self.v_th;
        let is_spiking = threshold_crossed && self.was_increasing && !increasing_right_now;

        self.is_spiking = is_spiking;
        self.was_increasing = increasing_right_now;

        is_spiking
    }
}

/// Takes in a static current as an input and iterates the given
/// neuron for a given duration, set `gaussian` to true to add 
/// normally distributed noise to the input as it iterates,
/// returns various state variables over time including voltages
/// and gating states
pub fn run_static_input_hodgkin_huxley<T: NeurotransmitterKinetics, R: ReceptorKinetics>(
    hodgkin_huxley_neuron: &mut HodgkinHuxleyNeuron<T, R>,
    input: f32,
    gaussian: bool,
    iterations: usize,
) -> HashMap<String, Vec<f32>> {
    let mut state_output = HashMap::new();
    state_output.insert("current_voltage".to_string(), vec![]);
    state_output.insert("m".to_string(), vec![]);
    state_output.insert("n".to_string(), vec![]);
    state_output.insert("h".to_string(), vec![]);

    for _ in 0..iterations {
        let current_input = if gaussian {
            input * hodgkin_huxley_neuron.get_gaussian_factor()
        } else {
            input
        };

        let _is_spiking = hodgkin_huxley_neuron.iterate_and_spike(current_input);

        state_output.get_mut("current_voltage").map(|val| val.push(hodgkin_huxley_neuron.current_voltage));
        state_output.get_mut("m").map(|val| val.push(hodgkin_huxley_neuron.na_channel.m.state));
        state_output.get_mut("n").map(|val| val.push(hodgkin_huxley_neuron.na_channel.h.state));
        state_output.get_mut("h").map(|val| val.push(hodgkin_huxley_neuron.k_channel.n.state));
    }

    state_output
}
