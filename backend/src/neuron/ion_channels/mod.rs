//! A series of ion channels and ion channel traits to implement for usage in neuron models

/// A gating variable for necessary ion channels
#[derive(Debug, Clone, Copy)]
pub struct BasicGatingVariable {
    /// Gating variable
    pub alpha: f32,
    /// Gating variable
    pub beta: f32,
    /// Current state of the gate
    pub state: f32,
}

impl Default for BasicGatingVariable {
    fn default() -> Self {
        BasicGatingVariable {
            alpha: 0.,
            beta: 0.,
            state: 0.,
        }
    }
}

impl BasicGatingVariable {
    /// Initializes the gating variable state
    pub fn init_state(&mut self) {
        self.state = self.alpha / (self.alpha + self.beta);
    }

    // Updates the gating variable based on a given timestep (ms)
    pub fn update(&mut self, dt: f32) {
        let alpha_state: f32 = self.alpha * (1. - self.state);
        let beta_state: f32 = self.beta * self.state;
        self.state += dt * (alpha_state - beta_state);
    }
}

// CHECK THIS PAPER TO CREATE MORE ION CHANNELS WHEN REFACTORING
// https://sci-hub.se/https://pubmed.ncbi.nlm.nih.gov/25282547/

// https://webpages.uidaho.edu/rwells/techdocs/Biological%20Signal%20Processing/Chapter%2004%20The%20Biological%20Neuron.pdf

// https://www.nature.com/articles/356441a0.pdf : calcium currents paper
// https://github.com/ModelDBRepository/151460/blob/master/CaT.mod // low threshold calcium current
// https://modeldb.science/279?tab=1 // low threshold calcium current (thalamic)
// https://github.com/gpapamak/snl/blob/master/IL_gutnick.mod // high threshold calcium current (l type)
// https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9373714/ // assume [Ca2+]in,inf is initial [Ca2+] value

/// Handles dynamics of an ion channel that does not need timestep information
pub trait TimestepIndependentIonChannel: TimestepIndependentIonChannelBoxClone + Sync + Send {
    /// Updates current based on the current voltage (mV)
    fn update_current(&mut self, voltage: f32);
    /// Returns the current
    fn get_current(&self) -> f32;
    /// Returns the name of the gate
    fn gate_type(&self) -> &str;
}

/// Handles dynamics of an ion channel
pub trait IonChannel: IonChannelBoxClone + Sync + Send {
    /// Initializes parameters based on a starting voltage (mV)
    fn initialize(&mut self, voltage: f32);
    /// Updates current based on the current voltage (mV) and a timestep (ms)
    fn update_current(&mut self, voltage: f32, dt: f32);
    /// Returns the current
    fn get_current(&self) -> f32;
    /// Returns the name of the gate
    fn gate_type(&self) -> &str;
}

/// Handles cloning of boxed dynamic gated ion channels
pub trait IonChannelBoxClone {
    fn clone_box(&self) -> Box<dyn IonChannel>;
}

impl<T: ?Sized> IonChannelBoxClone for T
where
    T: 'static + IonChannel + Clone,
{
    fn clone_box(&self) -> Box<dyn IonChannel> {
        Box::new(self.clone())
    }
}

impl Clone for Box<dyn IonChannel> {
    fn clone(&self) -> Box<dyn IonChannel> {
        self.clone_box()
    }
}

/// Handles cloning of boxed dynamic ungated ion channels
pub trait TimestepIndependentIonChannelBoxClone {
    fn clone_box(&self) -> Box<dyn TimestepIndependentIonChannel>;
}

impl<T: ?Sized> TimestepIndependentIonChannelBoxClone for T
where
    T: 'static + TimestepIndependentIonChannel + Clone,
{
    fn clone_box(&self) -> Box<dyn TimestepIndependentIonChannel> {
        Box::new(self.clone())
    }
}

impl Clone for Box<dyn TimestepIndependentIonChannel> {
    fn clone(&self) -> Box<dyn TimestepIndependentIonChannel> {
        self.clone_box()
    }
}

/// An implementation of a calcium channel
#[derive(Debug, Clone, Copy)]
pub struct CalciumIonChannel {
    /// Maximal conductance of the channel (nS)
    pub g_ca: f32,
    /// Reversal potential (mV)
    pub e_ca: f32,
    /// Gating variable
    pub s: BasicGatingVariable,
    /// Current generated by channel
    pub current: f32,
}

impl Default for CalciumIonChannel {
    fn default() -> Self {
        CalciumIonChannel {
            g_ca: 0.025, // https://www.ncbi.nlm.nih.gov/books/NBK6181/
            e_ca: 80.,
            s: BasicGatingVariable::default(),
            current: 0.,
        }
    }
}

// https://github.com/ModelDBRepository/121060/blob/master/chan_CaL12.mod
// https://github.com/gpapamak/snl/blob/master/IL_gutnick.mod
impl CalciumIonChannel {
    /// Updates the state of the gating variable based on voltage
    fn update_gate_states(&mut self, voltage: f32) {
        self.s.alpha = 1.6 / (1. + (-0.072 * (voltage - 5.)).exp());
        self.s.beta = (0.02 * (voltage + 8.9)) / (((voltage + 8.9).exp() / 5.) - 1.);
    }
}

// https://sci-hub.se/https://pubmed.ncbi.nlm.nih.gov/25282547/
// https://link.springer.com/referenceworkentry/10.1007/978-1-4614-7320-6_230-1
impl IonChannel for CalciumIonChannel {
    fn initialize(&mut self, voltage: f32) {
        self.update_gate_states(voltage);

        self.s.init_state()
    } 

    fn update_current(&mut self, voltage: f32, dt: f32) {
        self.update_gate_states(voltage);

        self.s.update(dt);

        self.current = -self.s.state.powf(2.) * self.g_ca * (voltage - self.e_ca);
    }

    fn get_current(&self) -> f32 {
        self.current
    }

    fn gate_type(&self) -> &str {
        "HVA Ca"
    }
}

/// A sodium ion channel
#[derive(Debug, Clone, Copy)]
pub struct NaIonChannel {
    /// Maximal conductance (nS)
    pub g_na: f32,
    /// Reversal potential (mV)
    pub e_na: f32,
    /// Gating variable that changes based on voltage
    pub m: BasicGatingVariable,
    /// Gating variable that changes based on voltage
    pub h: BasicGatingVariable,
    /// Current output
    pub current: f32,
}

impl Default for NaIonChannel {
    fn default() -> Self {    
        NaIonChannel {
            g_na: 120., 
            e_na: 115., 
            m: BasicGatingVariable::default(),
            h: BasicGatingVariable::default(),
            current: 0.,
        }
    }
}

impl NaIonChannel {
    /// Updates the state of the gating variable based on voltage
    fn update_gate_states(&mut self, voltage: f32) {
        self.m.alpha = 0.1 * ((25. - voltage) / (((25. - voltage) / 10.).exp() - 1.));
        self.m.beta = 4. * (-voltage / 18.).exp();
        self.h.alpha = 0.07 * (-voltage / 20.).exp();
        self.h.beta = 1. / (((30. - voltage) / 10.).exp() + 1.);
    }
}

impl IonChannel for NaIonChannel {
    fn initialize(&mut self, voltage: f32) {
        self.update_gate_states(voltage);

        self.m.init_state();
        self.h.init_state();
    }

    fn update_current(&mut self, voltage: f32, dt: f32) {
        self.update_gate_states(voltage);

        self.m.update(dt);
        self.h.update(dt);

        self.current = self.m.state.powf(3.) * self.h.state * self.g_na * (voltage - self.e_na);
    }

    fn get_current(&self) -> f32 {
        self.current
    }

    fn gate_type(&self) -> &str {
        "Na"
    }
}

/// A potassium ion channel
#[derive(Debug, Clone, Copy)]
pub struct KIonChannel {
    /// Maximal conductance (nS)
    pub g_k: f32,
    /// Reversal potential (mV)
    pub e_k: f32,
    /// Gating variable that changes based on voltage
    pub n: BasicGatingVariable,
    /// Current output
    pub current: f32,
}

impl Default for KIonChannel {
    fn default() -> Self {
        KIonChannel {
            g_k: 36., 
            e_k: -12., 
            n: BasicGatingVariable::default(),
            current: 0.,
        }
    }
}

impl KIonChannel {
    /// Updates the state of the gating variable based on voltage
    fn update_gate_states(&mut self, voltage: f32) {
        self.n.alpha = 0.01 * (10. - voltage) / (((10. - voltage) / 10.).exp() - 1.);
        self.n.beta = 0.125 * (-voltage / 80.).exp();
    }
}

impl IonChannel for KIonChannel {
    fn initialize(&mut self, voltage: f32) {
        self.update_gate_states(voltage);

        self.n.init_state();
    }

    fn update_current(&mut self, voltage: f32, dt: f32) {
        self.update_gate_states(voltage);

        self.n.update(dt);

        self.current = self.n.state.powf(4.) * self.g_k * (voltage - self.e_k);
    }

    fn get_current(&self) -> f32 {
        self.current
    }

    fn gate_type(&self) -> &str {
        "K"
    }
}

/// A potassium leak channel
#[derive(Debug, Clone, Copy)]
pub struct KLeakChannel {
    /// Maximal conductance (nS)
    pub g_k_leak: f32,
    /// Reversal potential (mV)
    pub e_k_leak: f32,
    /// Current output
    pub current: f32,
}

impl Default for KLeakChannel {
    fn default() -> Self {
        KLeakChannel {
            g_k_leak: 0.3, 
            e_k_leak: 10.6, 
            current: 0.,
        }
    }
}

impl TimestepIndependentIonChannel for KLeakChannel {
    fn update_current(&mut self, voltage: f32) {
        self.current = self.g_k_leak * (voltage - self.e_k_leak);
    }

    fn get_current(&self) -> f32 {
        self.current
    }

    fn gate_type(&self) -> &str {
        "K Leak"
    }
}
